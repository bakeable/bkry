import { defineStore } from 'pinia'
import { {{.TypeName}} } from './interface.gen'
import type { {{.TypeName}}Store, {{.TypeName}}StoreState } from './store.gen.d'
import { Pagination, paginationAndQueriesToCacheKey } from "../../general/pagination";
import { Query } from "../../general/query";
import { {{.TypeName}}Transporter } from './transport.gen'

/// ///////////////////////////////////////////////////////////////////////////////////////////////////
/// WARNING! THIS FILE IS AUTOMATICALLY GENERATED, ANY CHANGES WILL BE LOST ON NEXT GENERATION
/// IF YOU WANT TO EDIT THIS FILE, REMOVE THE .gen. FROM THE FILENAME. THE FILE WILL THEN BE IGNORED.
/// ///////////////////////////////////////////////////////////////////////////////////////////////////

export const use{{.TypeName}}Store = defineStore('{{.TypeNameLowercase}}Store', {
  state: (): {{.TypeName}}StoreState => ({
    activeID: null,
    cache: {},
    list: [] as {{.TypeName}}[],
    retrievalTimestamp: 0,
    updateKey: 0,
    storeUpdateTimeout: null,
  }),
  actions: {
    emitFormUpdateEvent(id: string): void {
      window.dispatchEvent(new CustomEvent("form.update.{{.EntityName}}", { detail: { id } }));
    },
    emitStoreUpdateEvent(): void {
      // Clear existing timeout
      if (this.storeUpdateTimeout !== null) {
        clearTimeout(this.storeUpdateTimeout)
      }

      // Set new timeout
      this.storeUpdateTimeout = setTimeout(() => {
        window.dispatchEvent(new CustomEvent("store.update.{{.EntityName}}"));
        this.storeUpdateTimeout = null
      }, 1500)
    },
    async activate({{.TypeNameLowercase}}: {{.TypeName}}): Promise<void> {
      // Set active
      this.activeID = {{.TypeNameLowercase}}.id
    },
    add({{.TypeNameLowercase}}: {{.TypeName}}): void {
      const id = {{.TypeNameLowercase}}.id
      if (typeof id === 'string' && !this.contains(id)) {
        this.list.push({{.TypeNameLowercase}})

        // Set active
        if (this.active === null) {
          this.activeID = {{.TypeNameLowercase}}.id
        }
      } else {
        this.reinsert({{.TypeNameLowercase}})
      }
      this.updateKey += 1;
    },
    async delete({{.TypeNameLowercase}}: {{.TypeName}}): Promise<void> {
      await {{.TypeName}}Transporter.Delete({{.TypeNameLowercase}}).then(() => {
        this.remove({{.TypeNameLowercase}})
      }).finally(() => {
        this.emitStoreUpdateEvent()
      });
    },
    async deleteById(id: string): Promise<void> {
      const {{.TypeNameLowercase}} = (this.list as {{.TypeName}}[]).find((x: {{.TypeName}}) => x.id === id)
      if ({{.TypeNameLowercase}} !== undefined) {
        await this.delete({{.TypeNameLowercase}})
      } else {
        throw new Error('Could not find {{.TypeName}} with id: ' + id)
      }
    },
    contains(id: string): boolean {
      return (this.list as {{.TypeName}}[]).some((x: {{.TypeName}}) => x.id === id)
    },
    async create({{range .ParentsCamelCase}}{{.}}Id: string, {{end}}{{.TypeNameLowercase}}: {{.TypeName}}): Promise<{{.TypeName}}> {
      // Create {{.TypeNameLowercase}}
      const item = await {{.TypeName}}Transporter.Create({ 
        {{- range .ParentsCamelCase}}
        {{.}}_id: {{.}}Id,
        {{- end}}
      }, {{.TypeNameLowercase}})

      // Reinsert {{.TypeNameLowercase}}
      this.reinsert(item)

      // Activate {{.TypeNameLowercase}}
      if (this.active === null) {
        await this.activate(item)
      }
      
      this.emitStoreUpdateEvent()

      return item
    },
    get(id: string): {{.TypeName}} | null {
      return (this.list as {{.TypeName}}[]).find((x: {{.TypeName}}) => x.id === id) || null
    },
    reinsert({{.TypeNameLowercase}}: {{.TypeName}}): void {
      const index = (this.list as {{.TypeName}}[]).findIndex((x: {{.TypeName}}) => x.id === {{.TypeNameLowercase}}.id)
      if (index !== -1) {
        this.list = [
          ...this.list.slice(0, index),
          {{.TypeNameLowercase}},
          ...this.list.slice(index + 1),
        ]
      } else {
        this.add({{.TypeNameLowercase}})
      }
      this.updateKey += 1;
    },
    remove({ id }: {{.TypeName}}): void {
      const index = (this.list as {{.TypeName}}[]).findIndex((x: {{.TypeName}}) => x.id === id)
      if (index !== -1) {
        this.list = [
          ...this.list.slice(0, index),
          ...this.list.slice(index + 1),
        ]
      }
      this.updateKey += 1;
    },
    async retrieve({{range .ParentsCamelCase}}{{.}}Id: string, {{end}}id: string, force = false): Promise<{{.TypeName}}> {
      // Check if a refresh is required
      if (!force && !this.refreshRequired) {
        const {{.TypeNameLowercase}} = this.get(id)
        if ({{.TypeNameLowercase}} !== null) {
          return {{.TypeNameLowercase}}
        }
      }

      // Get {{.TypeNameLowercase}}
      const {{.TypeNameLowercase}} = await {{.TypeName}}Transporter.Get({
        {{- range .ParentsSnakeCase}}
        {{.}}_id: {{.}}Id,
        {{- end}}
        id,
      }).then(async (entity) => {
        this.reinsert(entity)

        // Activate {{.TypeNameLowercase}}
        await this.activate(entity)

        return entity
      })

      return {{.TypeNameLowercase}}
    },
    async retrieveAll({{range .ParentsCamelCase}}{{.}}Id: string, {{end}}force = false): Promise<{
      active: string | null
      items: {{.TypeName}}[]
    }> {
      // Check if a refresh is required
      if (!force && !this.refreshRequired) {
        return {
          active: this.activeID,
          items: this.list as {{.TypeName}}[],
        }
      }

      // Clear list
      while (this.list.length > 0) {
        this.list.pop()
      }

      // Retrieve list
      await {{.TypeName}}Transporter.GetAll({{- if hasItems .ParentsSnakeCase}}{
        {{- range .ParentsSnakeCase}}
        {{.}}_id: {{.}}Id,
        {{- end}}
      }{{- end}}).then(async (list) => {
        list.forEach(({{.TypeNameLowercase}}) => {
          this.reinsert({{.TypeNameLowercase}})
        })

        // Activate {{.TypeNameLowercase}}
        if (list.length > 0) {
          if (this.activeID === null) {
            await this.activate(list[0])
          }
        }
      })

      // Set retrieval timestamp
      this.retrievalTimestamp = Date.now()

      return {
        active: this.activeID,
        items: this.list as {{.TypeName}}[],
      }
    },
    async retrievePaginated({{range .ParentsCamelCase}}{{.}}Id: string, {{end}}pagination: Pagination, force = false): Promise<{
      pagination: Pagination;
      items: {{.TypeName}}[];
    }> {
      // Check pagination
      let newPagination = new Pagination(pagination).deepCopy();

      // Get cachekey
      const cacheKey = pagination.toCacheKey();

      // Check if a refresh is required
      if (!force && this.cache[cacheKey]) {
        const cached = this.cache[cacheKey]
        return {
          pagination: cached.pagination.deepCopy(),
          items: cached.ids.map((id: string) => this.get(id) as {{.TypeName}}),
        };
      }

      // Retrieve list
      const items = await {{.TypeName}}Transporter.GetPaginated({{- if hasItems .ParentsSnakeCase}}{
        {{- range .ParentsSnakeCase}}
        {{.}}_id: {{.}}Id,
        {{- end}}
      }, {{- end}}pagination).then(async ({items, pagination }) => {
        // Set new pagination
        newPagination = pagination.deepCopy();;

        if (items === null) {
          return []
        }

        // Reinsert items
        items.forEach(({{.TypeNameLowercase}}) => {
          this.reinsert({{.TypeNameLowercase}});
        });


        return items
      });

      // Set cache
      this.cache[cacheKey] = {
        ids: items.map((x: {{.TypeName}}) => x.id),
        pagination: newPagination,
        retrievalTimestamp: Date.now(),
      };

      // Set retrieval timestamp
      this.retrievalTimestamp = Date.now();

      return {
        pagination: newPagination,
        items,
      };
    },
    async query({{range .ParentsCamelCase}}{{.}}Id: string, {{end}}pagination: Pagination, queries: Query[], force = false): Promise<{
      pagination: Pagination;
      items: {{.TypeName}}[];
    }> {
      // Check pagination
      let newPagination = new Pagination(pagination).deepCopy();

      // Get cachekey
      const cacheKey = paginationAndQueriesToCacheKey(pagination, queries);

      // Check if a refresh is required
      if (!force && this.cache[cacheKey]) {
        const cached = this.cache[cacheKey]
        return {
          pagination: cached.pagination.deepCopy(),
          items: cached.ids.map((id: string) => this.get(id) as {{.TypeName}}),
        };
      }

      // Retrieve list
      const items = await {{.TypeName}}Transporter.Query({{- if hasItems .ParentsSnakeCase}}{
        {{- range .ParentsSnakeCase}}
        {{.}}_id: {{.}}Id,
        {{- end}}
      }, {{- end}}
        pagination,
        queries,
      ).then(async ({ items, pagination }) => {
        // Set new pagination
        newPagination = pagination.deepCopy();;

        if (items === null) {
          return []
        }

        // Reinsert items
        items.forEach(({{.TypeNameLowercase}}) => {
          this.reinsert({{.TypeNameLowercase}});
        });


        return items
      });

      // Set cache
      this.cache[cacheKey] = {
        ids: items.map((x: {{.TypeName}}) => x.id),
        pagination: newPagination.deepCopy(),
        retrievalTimestamp: Date.now(),
      };

      // Set retrieval timestamp
      this.retrievalTimestamp = Date.now();

      return {
        pagination: newPagination,
        items: items,
      };
    },
    async search(
      {{range .ParentsCamelCase}}{{.}}Id: string, {{end}}
      pagination: Pagination,
      search: string,
      force = false,
    ): Promise<{
      pagination: Pagination;
      items: {{.TypeName}}[];
    }> {
      // Check pagination
      let newPagination = new Pagination(pagination).deepCopy();

      // Get cachekey
      const cacheKey = search.replaceAll(" ", "_") + '-' + pagination.toCacheKey();

      // Check if a refresh is required
      if (!force && this.cache[cacheKey]) {
        const cached = this.cache[cacheKey]
        return {
          items: cached.ids.map(
            (id: string) => this.get(id) as {{.TypeName}},
          ),
          pagination: cached.pagination.deepCopy(),
        };
      }

      // Retrieve list
      const items = await {{.TypeName}}Transporter.Search({{- if hasItems .ParentsSnakeCase}}{
        {{- range .ParentsSnakeCase}}
        {{.}}_id: {{.}}Id,
        {{- end}}
      }, {{- end}}
        pagination,
        search,
      ).then(async ({ items, pagination }) => {
        // Set new pagination
        newPagination = pagination.deepCopy();;

        if (items === null) {
          return []
        }

        // Reinsert items
        items.forEach(({{.TypeNameLowercase}}) => {
          this.reinsert({{.TypeNameLowercase}});
        });


        return items
      });

      // Set cache
      this.cache[cacheKey] = {
        ids: items.map((x: {{.TypeName}}) => x.id),
        pagination: newPagination.deepCopy(),
        retrievalTimestamp: Date.now(),
      };

      // Set retrieval timestamp
      this.retrievalTimestamp = Date.now();

      return {
        items: items,
        pagination: newPagination,
      };
    },
    async update({{.TypeNameLowercase}}: {{.TypeName}}): Promise<{{.TypeName}}> {
      // Update {{.TypeNameLowercase}}
      const item = await {{.TypeName}}Transporter.Update({{.TypeNameLowercase}})

      // Reinsert {{.TypeNameLowercase}}
      this.reinsert(item)

      // Activate {{.TypeNameLowercase}}
      if (this.active === null) {
        await this.activate(item)
      }
      
      this.emitStoreUpdateEvent()

      return item
    },
  },
  getters: {
    active(): {{.TypeName}} | null {
      if (this.activeID === null) {
        return null
      }

      const {{.TypeNameLowercase}} = (this.list as {{.TypeName}}[]).find((x: {{.TypeName}}) => x.id === this.activeID)
      if ({{.TypeNameLowercase}} === undefined) {
        return null
      }

      return {{.TypeNameLowercase}}
    },
    refreshRequired(): boolean {
      return (
        this.retrievalTimestamp === 0 ||
        this.retrievalTimestamp < Date.now() - 30 * 60000 ||
        this.list.length === 0
      )
    },
  },
})

// Export a function to create a new instance of the store
export function create{{.TypeName}}Store(): {{.TypeName}}Store {
  const store = use{{.TypeName}}Store()
  return store as unknown as {{.TypeName}}Store // TODO: Fix this
}
