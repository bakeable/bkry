import { type JSONData } from '../../base_classes/dto.d'
import { Dto } from '../../base_classes/dto'
import type { I{{.TypeName}}Dto, {{range .Fields}}{{if .IsChildStruct}}I{{.FieldName}}, {{end}}{{end}}{{range .EnumValuesByType }}{{.EnumType}}, {{end}} } from './dto.gen.d'
{{- range .TypeScriptImports }}
{{.}}
{{- end }}

/// ///////////////////////////////////////////////////////////////////////////////////////////////////
/// WARNING! THIS FILE IS AUTOMATICALLY GENERATED, ANY CHANGES WILL BE LOST ON NEXT GENERATION
/// ///////////////////////////////////////////////////////////////////////////////////////////////////


// Types
{{- range .EnumValuesByType }}
export const {{.EnumType}}Values: Record<string,{{.EnumType}}> = Object.freeze({
  {{- range .EnumValuesFormatted }}
  {{.Uppercase}}: '{{.Value}}',
  {{- end }}
})
{{- end }}

export class {{.TypeName}}Dto extends Dto implements I{{.TypeName}}Dto {
  /// ///////////////////////////////////////
  /// //////// PRIVATE VARIABLES ////////////
  /// ///////////////////////////////////////
  _path = '{{.ClientEndpoint}}/{id}'
  _reference = '{{.CollectionReference}}/{id}'

  /// ///////////////////////////////////////
  /// ///////// PUBLIC VARIABLES ////////////
  /// ///////////////////////////////////////
  {{- range .Fields }}
    {{if .FieldTypeIsExternal }}
    {{- if .IsArray }}
    {{.JsonName}}: {{.FieldTypeClient}}[] = []
    {{- else }}
    {{.JsonName}} = new {{.FieldTypeClient}}()
    {{- end }}
    {{else if .IsChildStruct }}
    {{.JsonName}}: I{{.FieldName}}{{if .IsArray}}[]{{end}} = {{if .IsArray}}[]{{ else }}{
      {{- template "generateInitObject" .Fields }}
    }{{end}}

    {{else }}
    {{.JsonName}} = {{.DefaultValueClient}}
    {{end }}
  {{- end }}

  /// ///////////////////////////////////////
  /// ///////////// METHODS /////////////////
  /// ///////////////////////////////////////

  static FromJSON(data: unknown): {{.TypeName}}Dto {
    // Create a new instance of the class
    const obj = new {{.TypeName}}Dto()
    obj.set(data as JSONData)
    return obj
  }

  static FromJSONArray(data: unknown[]): {{.TypeName}}Dto[] {
    return data.map((item) => {{.TypeName}}Dto.FromJSON(item))
  }

  override set(data: JSONData): void {
    super.set(data)
 
    // Implement variables here
    {{- range .Fields }}
    if (data.{{.JsonName}} !== undefined && data.{{.JsonName}} !== null {{if .IsArray}}&& Array.isArray(data.{{.JsonName}}){{end}}) {
      {{- if .IsEnum}}
        {{- if .IsArray}}
        this.{{.JsonName}} = (data.{{.JsonName}} as string[] ?? this.{{.JsonName}}).map((item) => {{.FieldType}}Values[item.toUpperCase()])
        {{- else}}
        this.{{.JsonName}} = {{.FieldType}}Values[(data?.{{.JsonName}} as string)?.toUpperCase() ?? this.{{.JsonName}}.toUpperCase()]
        {{- end}}
      {{- else if .FieldTypeIsExternal }} 
        {{- if .IsArray }}
      this.{{.JsonName}} = {{.FieldTypeClient}}.FromJSONArray(data.{{.JsonName}} as JSONData[])
        {{- else }}
      if (!this.{{.JsonName}}) {
        this.{{.JsonName}} = new {{.FieldTypeClient}}()
      }
      this.{{.JsonName}}.set(data.{{.JsonName}} as JSONData ?? this.{{.JsonName}}.toJSON())
        {{- end }}
      {{- else if .IsChildStruct}}
      if (data.{{.JsonName}}) {
        {{- if .IsArray}}
        this.{{.JsonName}} = {{.FieldName}}.FromJSONArray(data.{{.JsonName}} as JSONData[])
        {{- else}}
        this.{{.JsonName}} = {{.FieldName}}.FromJSON(data.{{.JsonName}})
        {{- end}}
      }
      {{- else}}
      this.{{.JsonName}} = data.{{.JsonName}} as {{.FieldTypeClient}}{{if .IsArray}}[]{{end}} ?? this.{{.JsonName}}
      {{end}}
    }
    {{- end }}
  }

}

{{- range .Fields }}
{{- if .IsChildStruct }}
{{template "generateHelperClass" .}}
{{- end }}
{{- end }}


{{- define "generateHelperClass" }}
export class {{.FieldName}} implements I{{.FieldName}} {
  /// ///////////////////////////////////////
  /// ///////// PUBLIC VARIABLES ////////////
  /// ///////////////////////////////////////
  {{- range .Fields }}
    {{if or .FieldTypeIsExternal .IsChildStruct }}
      {{- if .IsArray }}
      {{.JsonName}}: {{.FieldTypeClient}}[] = []
      {{- else }}
      {{.JsonName}} = new {{.FieldTypeClient}}()
      {{- end }}
    {{else }}
      {{.JsonName}} = {{.DefaultValueClient}}
    {{end }}
  {{- end }}

  /// ///////////////////////////////////////
  /// ///////////// METHODS /////////////////
  /// ///////////////////////////////////////

  static FromJSON(data: unknown): {{.FieldName}} {
    // Create a new instance of the class
    const obj = new {{.FieldName}}()
    obj.set(data as JSONData)
    return obj
  }

  static FromJSONArray(data: unknown[]): {{.FieldName}}[] {
    return data.map((item) => {{.FieldName}}.FromJSON(item))
  }


  set(data: JSONData): void {
    // Implement variables here
    {{- range .Fields }}
    if (data.{{.JsonName}} !== undefined && data.{{.JsonName}} !== null {{if .IsArray}}&& Array.isArray(data.{{.JsonName}}){{end}}) {
      {{- if .IsEnum}}
        {{- if .IsArray}}
        this.{{.JsonName}} = (data.{{.JsonName}} as string[] ?? this.{{.JsonName}}).map((item) => {{.FieldType}}Values[item.toUpperCase()])
        {{- else}}
        this.{{.JsonName}} = {{.FieldType}}Values[(data?.{{.JsonName}} as string)?.toUpperCase() ?? this.{{.JsonName}}.toUpperCase()]
        {{- end}}
      {{- else if .FieldTypeIsExternal }} 
        {{- if .IsArray }}
      this.{{.JsonName}} = {{.FieldTypeClient}}.FromJSONArray(data.{{.JsonName}} as JSONData[])
        {{- else }}
      if (!this.{{.JsonName}}) {
        this.{{.JsonName}} = new {{.FieldTypeClient}}()
      }
      this.{{.JsonName}}.set(data.{{.JsonName}} as JSONData ?? this.{{.JsonName}}.toJSON())
        {{- end }}
      {{- else if .IsChildStruct}}
      if (data.{{.JsonName}}) {
        {{- if .IsArray}}
        this.{{.JsonName}} = {{.FieldName}}.FromJSONArray(data.{{.JsonName}} as JSONData[])
        {{- else}}
        this.{{.JsonName}} = {{.FieldName}}.FromJSON(data.{{.JsonName}})
        {{- end}}
      }
      {{- else}}
      this.{{.JsonName}} = data.{{.JsonName}} as {{.FieldTypeClient}}{{if .IsArray}}[]{{end}} ?? this.{{.JsonName}}
      {{end}}
    }
    {{- end }}
  }
}

{{- range .Fields }}
{{- if not .ChildStructAlreadyExists }}
{{- if .IsChildStruct }}
{{template "generateChildHelperClass" .}}
{{- end }}
{{- end }}

{{- end }}
{{- end }}

{{- define "generateChildHelperClass" }}
export class {{.FieldName}} {
  /// ///////////////////////////////////////
  /// ///////// PUBLIC VARIABLES ////////////
  /// ///////////////////////////////////////
  {{- range .Fields }}
    {{if .FieldTypeIsExternal }}
      {{- if .IsArray }}
      {{.JsonName}}: {{.FieldTypeClient}}[] = []
      {{- else }}
      {{.JsonName}} = new {{.FieldTypeClient}}()
      {{- end }}
    {{else }}
      {{.JsonName}} = {{.DefaultValueClient}}
    {{end }}
  {{- end }}

  /// ///////////////////////////////////////
  /// ///////////// METHODS /////////////////
  /// ///////////////////////////////////////

  static FromJSON(data: unknown): {{.FieldName}} {
    // Create a new instance of the class
    const obj = new {{.FieldName}}()
    obj.set(data as JSONData)
    return obj
  }

  static FromJSONArray(data: unknown[]): {{.FieldName}}[] {
    return data.map((item) => {{.FieldName}}.FromJSON(item))
  }


  set(data: JSONData): void {
    // Implement variables here
    {{- range .Fields }}
    if (data.{{.JsonName}} !== undefined && data.{{.JsonName}} !== null {{if .IsArray}}&& Array.isArray(data.{{.JsonName}}){{end}}) {
      {{- if .IsEnum}}
        {{- if .IsArray}}
        this.{{.JsonName}} = (data.{{.JsonName}} as string[] ?? this.{{.JsonName}}).map((item) => {{.FieldType}}Values[item.toUpperCase()])
        {{- else}}
        this.{{.JsonName}} = {{.FieldType}}Values[(data?.{{.JsonName}} as string)?.toUpperCase()  ?? this.{{.JsonName}}.toUpperCase()]
        {{- end}}
      {{- else if .FieldTypeIsExternal }} 
        {{- if .IsArray }}
      this.{{.JsonName}} = {{.FieldTypeClient}}.FromJSONArray(data.{{.JsonName}} as JSONData[])
        {{- else }}
      if (!this.{{.JsonName}}) {
        this.{{.JsonName}} = new {{.FieldTypeClient}}()
      }
      this.{{.JsonName}}.set(data.{{.JsonName}} as JSONData ?? this.{{.JsonName}}.toJSON())
        {{- end }}
      {{- else if .IsChildStruct}}
      if (data.{{.JsonName}}) {
        {{- if .IsArray}}
        this.{{.JsonName}} = {{.FieldName}}.FromJSONArray(data.{{.JsonName}} as JSONData[])
        {{- else}}
        this.{{.JsonName}} = {{.FieldName}}.FromJSON(data.{{.JsonName}})
        {{- end}}
      }
      {{- else}}
      this.{{.JsonName}} = data.{{.JsonName}} as {{.FieldTypeClient}}{{if .IsArray}}[]{{end}} ?? this.{{.JsonName}}
      {{end}}
    }
    {{- end }}
  }
}

{{- range .Fields }}
{{- if not .ChildStructAlreadyExists }}
{{- if .IsChildStruct }}
{{template "generateChildHelperClass" .}}
{{- end }}
{{- end }}

{{- end }}
{{- end }}


{{- define "generateInitObject" }}
{{- range . }}
    {{- if .FieldTypeIsExternal }}
      {{.JsonName}}: new {{.FieldTypeClient}}(),
    {{- else if .IsChildStruct }}
    {{.JsonName}}: {{if .IsArray}}[]{{ else }}{
      {{- template "generateInitObject" .Fields }}
    }{{end}},
    {{- else }}
      {{.JsonName}}: {{.DefaultValueClient}},
    {{- end }}
{{- end }}
{{- end }}





{{- define "generateSetObject" }}
{{- range . }}
    {{- if .IsEnum}}
      {{- if .IsArray}}
      this.{{.JsonName}} = (x{{.ParentDepth}}.{{.JsonName}} as string[] ?? this.{{.JsonName}}).map((item) => {{.FieldType}}Values[item.toUpperCase()])
      {{- else}}
      this.{{.JsonName}} = {{.FieldType}}Values[(x{{.ParentDepth}}?.{{.JsonName}} as string)?.toUpperCase() ?? this.{{.JsonName}}.toUpperCase()]
      {{- end}}
    {{- else if .FieldTypeIsExternal }}
      {{.JsonName}}: (() => {
        const obj = new {{.FieldTypeClient}}()
        obj.set(data.{{.ParentObjectPathSafe}}{{.JsonName}} as unknown)
        return obj
      })(),
    {{- else if .IsChildStruct }}
    {{.JsonName}}: {{if .IsArray}}(x{{.ParentDepth}}.{{.JsonName}} as any[]).map((_: unknown, i{{.Depth}}: number) => {
      const x{{.Depth}} = (x{{.ParentDepth}}.{{.JsonName}} as JSONData[])[i{{.Depth}}]
      return {
        {{- template "generateSetObject" .Fields }}
      }
    }){{ else }}{
      {{- template "generateSetObject" .Fields }}
    }{{end}},
    {{- else }}
      {{.JsonName}}: x{{.ParentDepth}}.{{.JsonName}} as {{.FieldTypeClient}}{{if .IsArray}}[]{{end}},
    {{- end }}
{{- end }}
{{- end }}
