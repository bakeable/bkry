package {{.EntityName}}

import (
	"github.com/bakeable/bkry/tools"
{{- range .StructImports }}
	"{{.}}"
{{- end }}
	"github.com/bakeable/bkry/data/general/auditinfo"
)

// Decode converts a map to {{.TypeName}} struct
func Decode(m interface{}) {{.TypeName}} {
	if m, ok := m.(map[string]interface{}); ok {
		return {{.TypeName}}{
			ID: utils.TryDecodeString(m["id"]),
			Created: auditinfo.Decode(m["created"]),
			Modified: auditinfo.Decode(m["modified"]),
			{{- range .Fields }}
			{{- if .IsArray}}
				{{- if .IsEnum}}
			{{.FieldName}}: utils.DecodeStringArray(m["{{.JsonName}}"], {{.DefaultValue}}),
				{{- else if .FieldTypeIsExternal}}
			{{.FieldName}}: {{.FieldTypeDecoder}}All(m["{{.JsonName}}"]),
				{{- else}}
			{{.FieldName}}: Decode{{.FieldType}}Array(m["{{.JsonName}}"]),
				{{- end}}
			{{- else if .IsChildStruct}}
			{{.FieldName}}: Decode{{.FieldType}}(m["{{.JsonName}}"]),
			{{- else if .IsEnum}}
			{{.FieldName}}: {{.FieldType}}(utils.DecodeString(m["{{.JsonName}}"], {{.DefaultValue}})),
			{{- else}}
			{{.FieldName}}: {{.FieldTypeDecoder}}(m["{{.JsonName}}"]{{if not .FieldTypeIsExternal}}, {{.DefaultValue}}{{end}}),
			{{- end }}
			{{- end }}
		}
	}

	return {{.TypeName}}{}
}

// DecodeAll converts a slice of maps to a slice of {{.TypeName}} struct
func DecodeAll(ms interface{}) []{{.TypeName}} {
	var entities []{{.TypeName}}

	if arr, ok := ms.([]map[string]interface{}); ok {
		for _, m := range arr {
			entities = append(entities, Decode(m))
		}
		return entities
	}

	if arr, ok := ms.([]interface{}); ok {
		for _, m := range arr {
			entities = append(entities, Decode(m))
		}
		return entities
	}

	return entities
}

{{- template "generateDecodeChildStructs" .Fields }}

{{- define "generateDecodeChildStructs" }}
{{- range . }}
{{- if .IsChildStruct }}

// Decode{{.FieldType}}{{if .IsArray}}Array{{end}} converts a map to {{.FieldType}} struct
func Decode{{.FieldType}}{{if .IsArray}}Array{{end}}(m interface{}) {{if .IsArray}}[]{{end}}{{.FieldType}} {
{{- if .IsArray }}
	if m == nil {
		return []{{.FieldType}}{}
	}
	if vArr, ok := m.([]map[string]interface{}); ok {
		var entities []{{.FieldType}}
		for _, v := range vArr {
			if v == nil {
				continue
			}
			entities = append(entities, {{.FieldType}}{
				{{- range .Fields }}
				{{.FieldName}}: {{if .IsChildStruct}}Decode{{.FieldType}}{{if .IsArray}}Array{{end}}(v["{{.JsonName}}"]){{else if .IsEnum}}{{.FieldType}}(utils.DecodeString(v["{{.JsonName}}"], {{.DefaultValue}})){{else}}{{.FieldTypeDecoder}}{{if .IsArray}}All{{end}}(v["{{.JsonName}}"]{{if not .FieldTypeIsExternal}}, {{.DefaultValue}}{{end}}){{end}},
				{{- end }}
			})
		}
		return entities
	}
	if vArr, ok := m.([]interface{}); ok {
		var entities []{{.FieldType}}
		for _, v := range vArr {
			if v == nil {
				continue
			}
			if val, ok := v.(map[string]interface{}); ok {
				entities = append(entities, {{.FieldType}}{
					{{- range .Fields }}
					{{.FieldName}}: {{if .IsChildStruct}}Decode{{.FieldType}}{{if .IsArray}}Array{{end}}(val["{{.JsonName}}"]){{else if .IsEnum}}{{.FieldType}}(utils.DecodeString(val["{{.JsonName}}"], {{.DefaultValue}})){{else}}{{.FieldTypeDecoder}}{{if .IsArray}}All{{end}}(val["{{.JsonName}}"]{{if not .FieldTypeIsExternal}}, {{.DefaultValue}}{{end}}){{end}},
					{{- end }}
				})
			}
		}
		return entities
	}
	return []{{.FieldType}}{}
{{- else }}
	if m == nil {
		return {{.FieldType}}{}
	}
	if val, ok := m.(map[string]interface{}); ok {
		return {{.FieldType}}{
			{{- range .Fields }}
			{{.FieldName}}: {{if .IsChildStruct}}Decode{{.FieldType}}{{if .IsArray}}Array{{end}}(val["{{.JsonName}}"]){{else if .IsEnum}}{{.FieldType}}(utils.DecodeString(val["{{.JsonName}}"], {{.DefaultValue}})){{else}}{{.FieldTypeDecoder}}{{if .IsArray}}All{{end}}(val["{{.JsonName}}"]{{if not .FieldTypeIsExternal}}, {{.DefaultValue}}{{end}}){{end}},
			{{- end }}
		}
	}
	return {{.FieldType}}{}
{{- end }}
}
{{- template "generateDecodeChildStructs" .Fields }}
{{- end }}
{{- end }}
{{end }}
