import { type JSONData } from '../../base_classes/dto.d'
import { Dto } from '../../base_classes/dto'
import type { IAttributeDto, IDefaultOptions, AttributeType, AttributeIncrementalPricing, AttributePriceType,  } from './dto.gen.d'

/// ///////////////////////////////////////////////////////////////////////////////////////////////////
/// WARNING! THIS FILE IS AUTOMATICALLY GENERATED, ANY CHANGES WILL BE LOST ON NEXT GENERATION
/// ///////////////////////////////////////////////////////////////////////////////////////////////////


// Types
export const AttributeTypeValues: Record<string,AttributeType> = Object.freeze({
  TEXT: 'text',
  KEY_VALUE: 'key_value',
  NUMBER: 'number',
  RANGE: 'range',
  UNITS: 'units',
  OPTIONAL: 'optional',
})
export const AttributeIncrementalPricingValues: Record<string,AttributeIncrementalPricing> = Object.freeze({
  STAGGERED: 'staggered',
  STANDARD: 'standard',
})
export const AttributePriceTypeValues: Record<string,AttributePriceType> = Object.freeze({
  VARIABLE: 'variable',
  FIXED: 'fixed',
})

export class AttributeDto extends Dto implements IAttributeDto {
  /// ///////////////////////////////////////
  /// //////// PRIVATE VARIABLES ////////////
  /// ///////////////////////////////////////
  _path = '/attribute/{id}'
  _reference = '/Attribute/{id}'

  /// ///////////////////////////////////////
  /// ///////// PUBLIC VARIABLES ////////////
  /// ///////////////////////////////////////
    
    default = true
    
    
    defaultOptions: IDefaultOptions[] = []

    
    
    description = ""
    
    
    included = false
    
    
    incrementalPricing = AttributeIncrementalPricingValues.standard
    
    
    key = ""
    
    
    _kind = "Attribute"
    
    
    maxOptionId = 0
    
    
    name = ""
    
    
    nid = 0
    
    
    optionSets: attribute_option_set.AttributeOptionSet[] = []
    
    
    optional = false
    
    
    options: attribute_option.AttributeOption[] = []
    
    
    order = 0
    
    
    prefix = ""
    
    
    priceTypes = [AttributePriceTypeValues.variable]
    
    
    surcharges = map[string]interface{}{}
    
    
    type = AttributeTypeValues.text
    

  /// ///////////////////////////////////////
  /// ///////////// METHODS /////////////////
  /// ///////////////////////////////////////

  static FromJSON(data: unknown): AttributeDto {
    // Create a new instance of the class
    const obj = new AttributeDto()
    obj.set(data as JSONData)
    return obj
  }

  static FromJSONArray(data: unknown[]): AttributeDto[] {
    return data.map((item) => AttributeDto.FromJSON(item))
  }

  override set(data: JSONData): void {
    super.set(data)
 
    // Implement variables here
    if (data.default !== undefined && data.default !== null ) {
      this.default = data.default as boolean ?? this.default
      
    }
    if (data.defaultOptions !== undefined && data.defaultOptions !== null && Array.isArray(data.defaultOptions)) {
      if (data.defaultOptions) {
        this.defaultOptions = DefaultOptions.FromJSONArray(data.defaultOptions as JSONData[])
      }
    }
    if (data.description !== undefined && data.description !== null ) {
      this.description = data.description as string ?? this.description
      
    }
    if (data.included !== undefined && data.included !== null ) {
      this.included = data.included as boolean ?? this.included
      
    }
    if (data.incrementalPricing !== undefined && data.incrementalPricing !== null ) {
        this.incrementalPricing = AttributeIncrementalPricingValues[(data?.incrementalPricing as string)?.toUpperCase() ?? this.incrementalPricing.toUpperCase()]
    }
    if (data.key !== undefined && data.key !== null ) {
      this.key = data.key as string ?? this.key
      
    }
    if (data._kind !== undefined && data._kind !== null ) {
      this._kind = data._kind as string ?? this._kind
      
    }
    if (data.maxOptionId !== undefined && data.maxOptionId !== null ) {
      this.maxOptionId = data.maxOptionId as number ?? this.maxOptionId
      
    }
    if (data.name !== undefined && data.name !== null ) {
      this.name = data.name as string ?? this.name
      
    }
    if (data.nid !== undefined && data.nid !== null ) {
      this.nid = data.nid as number ?? this.nid
      
    }
    if (data.optionSets !== undefined && data.optionSets !== null && Array.isArray(data.optionSets)) {
      this.optionSets = attribute_option_set.AttributeOptionSet.FromJSONArray(data.optionSets as JSONData[])
    }
    if (data.optional !== undefined && data.optional !== null ) {
      this.optional = data.optional as boolean ?? this.optional
      
    }
    if (data.options !== undefined && data.options !== null && Array.isArray(data.options)) {
      this.options = attribute_option.AttributeOption.FromJSONArray(data.options as JSONData[])
    }
    if (data.order !== undefined && data.order !== null ) {
      this.order = data.order as number ?? this.order
      
    }
    if (data.prefix !== undefined && data.prefix !== null ) {
      this.prefix = data.prefix as string ?? this.prefix
      
    }
    if (data.priceTypes !== undefined && data.priceTypes !== null && Array.isArray(data.priceTypes)) {
        this.priceTypes = (data.priceTypes as string[] ?? this.priceTypes).map((item) => AttributePriceTypeValues[item.toUpperCase()])
    }
    if (data.surcharges !== undefined && data.surcharges !== null ) {
      this.surcharges = data.surcharges as Record<string, any> ?? this.surcharges
      
    }
    if (data.type !== undefined && data.type !== null ) {
        this.type = AttributeTypeValues[(data?.type as string)?.toUpperCase() ?? this.type.toUpperCase()]
    }
  }

}

export class DefaultOptions implements IDefaultOptions {
  /// ///////////////////////////////////////
  /// ///////// PUBLIC VARIABLES ////////////
  /// ///////////////////////////////////////
    
      id = ""
    
    
      key = ""
    
    
      max = 0
    
    
      min = 0
    
    
      value = ""
    

  /// ///////////////////////////////////////
  /// ///////////// METHODS /////////////////
  /// ///////////////////////////////////////

  static FromJSON(data: unknown): DefaultOptions {
    // Create a new instance of the class
    const obj = new DefaultOptions()
    obj.set(data as JSONData)
    return obj
  }

  static FromJSONArray(data: unknown[]): DefaultOptions[] {
    return data.map((item) => DefaultOptions.FromJSON(item))
  }


  set(data: JSONData): void {
    // Implement variables here
    if (data.id !== undefined && data.id !== null ) {
      this.id = data.id as string ?? this.id
      
    }
    if (data.key !== undefined && data.key !== null ) {
      this.key = data.key as string ?? this.key
      
    }
    if (data.max !== undefined && data.max !== null ) {
      this.max = data.max as number ?? this.max
      
    }
    if (data.min !== undefined && data.min !== null ) {
      this.min = data.min as number ?? this.min
      
    }
    if (data.value !== undefined && data.value !== null ) {
      this.value = data.value as string ?? this.value
      
    }
  }
}
