import { type JSONData } from '../../base_classes/dto.d'
import { Dto } from '../../base_classes/dto'
import type { IExaminationPropertyDto, IAcceptanceRegion, ExaminationInputType,  } from './dto.gen.d'

/// ///////////////////////////////////////////////////////////////////////////////////////////////////
/// WARNING! THIS FILE IS AUTOMATICALLY GENERATED, ANY CHANGES WILL BE LOST ON NEXT GENERATION
/// ///////////////////////////////////////////////////////////////////////////////////////////////////


// Types
export const ExaminationInputTypeValues: Record<string,ExaminationInputType> = Object.freeze({
  VALUE: 'value',
  CONFIRM: 'confirm',
})

export class ExaminationPropertyDto extends Dto implements IExaminationPropertyDto {
  /// ///////////////////////////////////////
  /// //////// PRIVATE VARIABLES ////////////
  /// ///////////////////////////////////////
  _path = '/examination_property/{id}'
  _reference = '/ExaminationProperty/{id}'

  /// ///////////////////////////////////////
  /// ///////// PUBLIC VARIABLES ////////////
  /// ///////////////////////////////////////
    
    acceptanceRegion: IAcceptanceRegion = {
      max: 0.0,
      min: 0.0,
      symmetric: false,
      type: "",
      value: 0.0,
    }

    
    
    description = ""
    
    
    examine = true
    
    
    info = {} satisfies Record<string, any>
    
    
    inputType = ExaminationInputTypeValues.value
    
    
    instructions = ""
    
    
    key = ""
    
    
    _kind = "ExaminationProperty"
    
    
    name = ""
    
    
    productId = ""
    
    
    productSpecific = false
    
    
    required = true
    
    
    testable = true
    
    
    type = ""
    
    
    unitType = ""
    

  /// ///////////////////////////////////////
  /// ///////////// METHODS /////////////////
  /// ///////////////////////////////////////

  static FromJSON(data: unknown): ExaminationPropertyDto {
    // Create a new instance of the class
    const obj = new ExaminationPropertyDto()
    obj.set(data as JSONData)
    return obj
  }

  static FromJSONArray(data: unknown[]): ExaminationPropertyDto[] {
    return data.map((item) => ExaminationPropertyDto.FromJSON(item))
  }

  override set(data: JSONData): void {
    super.set(data)
 
    // Implement variables here
    if (data.acceptanceRegion !== undefined && data.acceptanceRegion !== null ) {
      if (data.acceptanceRegion) {
        this.acceptanceRegion = AcceptanceRegion.FromJSON(data.acceptanceRegion)
      }
    }
    if (data.description !== undefined && data.description !== null ) {
      this.description = data.description as string ?? this.description
      
    }
    if (data.examine !== undefined && data.examine !== null ) {
      this.examine = data.examine as boolean ?? this.examine
      
    }
    if (data.info !== undefined && data.info !== null ) {
      this.info = data.info as Record<string, any> ?? this.info
      
    }
    if (data.inputType !== undefined && data.inputType !== null ) {
        this.inputType = ExaminationInputTypeValues[(data?.inputType as string)?.toUpperCase() ?? this.inputType.toUpperCase()]
    }
    if (data.instructions !== undefined && data.instructions !== null ) {
      this.instructions = data.instructions as string ?? this.instructions
      
    }
    if (data.key !== undefined && data.key !== null ) {
      this.key = data.key as string ?? this.key
      
    }
    if (data._kind !== undefined && data._kind !== null ) {
      this._kind = data._kind as string ?? this._kind
      
    }
    if (data.name !== undefined && data.name !== null ) {
      this.name = data.name as string ?? this.name
      
    }
    if (data.productId !== undefined && data.productId !== null ) {
      this.productId = data.productId as string ?? this.productId
      
    }
    if (data.productSpecific !== undefined && data.productSpecific !== null ) {
      this.productSpecific = data.productSpecific as boolean ?? this.productSpecific
      
    }
    if (data.required !== undefined && data.required !== null ) {
      this.required = data.required as boolean ?? this.required
      
    }
    if (data.testable !== undefined && data.testable !== null ) {
      this.testable = data.testable as boolean ?? this.testable
      
    }
    if (data.type !== undefined && data.type !== null ) {
      this.type = data.type as string ?? this.type
      
    }
    if (data.unitType !== undefined && data.unitType !== null ) {
      this.unitType = data.unitType as string ?? this.unitType
      
    }
  }

}

export class AcceptanceRegion implements IAcceptanceRegion {
  /// ///////////////////////////////////////
  /// ///////// PUBLIC VARIABLES ////////////
  /// ///////////////////////////////////////
    
      max = 0.0
    
    
      min = 0.0
    
    
      symmetric = false
    
    
      type = ""
    
    
      value = 0.0
    

  /// ///////////////////////////////////////
  /// ///////////// METHODS /////////////////
  /// ///////////////////////////////////////

  static FromJSON(data: unknown): AcceptanceRegion {
    // Create a new instance of the class
    const obj = new AcceptanceRegion()
    obj.set(data as JSONData)
    return obj
  }

  static FromJSONArray(data: unknown[]): AcceptanceRegion[] {
    return data.map((item) => AcceptanceRegion.FromJSON(item))
  }


  set(data: JSONData): void {
    // Implement variables here
    if (data.max !== undefined && data.max !== null ) {
      this.max = data.max as number ?? this.max
      
    }
    if (data.min !== undefined && data.min !== null ) {
      this.min = data.min as number ?? this.min
      
    }
    if (data.symmetric !== undefined && data.symmetric !== null ) {
      this.symmetric = data.symmetric as boolean ?? this.symmetric
      
    }
    if (data.type !== undefined && data.type !== null ) {
      this.type = data.type as string ?? this.type
      
    }
    if (data.value !== undefined && data.value !== null ) {
      this.value = data.value as number ?? this.value
      
    }
  }
}
